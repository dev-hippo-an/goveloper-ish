# 복합 타입
***
## 배열
- 배열의 모든 요소는 같은 타입으로 지정되어야 한다.
```go
var x [10]int  // 10개의 요소를 가지는 배열을 생성하고 타입의 제로값인 0 으로 초기화 된다.
var y = [3]int{10, 11, 12}  // 배열 리터럴로 선언하기
var w = [10]int{1, 5:4, 1, 9: 1}  // {1, 0, 0, 0, 0, 4, 1, 0, 0, 1} 희소 배열 만들기
var t = [...]int{1, 2, 3}  // 리터럴로 초기화시 ... 으로 배열의 개수를 넣지 않고 초기화
var a = [2][3]int  // 다차원 배열
x[0] = 1  // 쓰기
second := x[1]  // 읽기
```
- 인덱스 범위를 넘어선 읽기, 쓰기 작업은 런타임시 패닉을 발생시킨다.
- 내장 함수 len 함수를 사용해 배열의 길이를 알 수 있다.
- Go 에선 배열의 크기를 타입의 일부로 간주하기 때문에 많이 사용되지 않는다. 
  - 동일 타입의 다른 크기의 배열은 배열간 타입 변화도 할 수 없고 동일 변수에 크기가 다른 배열을 할당할 수도 없다.
  - 배열의 크기가 정해진 상황이 아닌 이상 사용하지 말자.
***
## 슬라이스
- 배열과 다르게 슬라이스는 슬라이스의 크기를 타입의 일부로 간주하지 않기 때문에 같은 타입의 여러 요소를 가진 자료구조를 사용할 때는 슬라이스를 사용한다.
```go
var x = []int{1, 2, 3, 4}  // 배열과 다르게 슬라이스는 초기화 시 크기 지정을 할 필요가 없다.
var w = []int{1, 5:4, 1, 9: 1}  // {1, 0, 0, 0, 0, 4, 1, 0, 0, 1} 희소 배열 만들기
var t = [][]int
var y []int  // 슬라이스의 제로 값은 nil 로 할당된다. 배열은 타입의 제로값으로 할당되지만 슬라이스는 타입의 제로값이 아닌 nil 로 할당된다.
```
- 슬라이스가 nil 이라는 것은 어떤 요소도 가지고 있지 않다는 뜻이다.
- 슬라이스는 nil 과 비교만 가능하고 슬라이스끼리의 비교는 불가능하다.
- 슬라이스 선언 시 슬라이스 내부적으로 확장되는 횟수를 최소화하는 것이 중요하다.
- 슬라이스는 [:] 의 형태로 슬라이싱이 가능하다.
  - 이 경우 메모리를 공유하는 두개의 변수를 가지게 되다. 이는 한 쪽 슬라이스의 수정이 다르 쪽에 영향을 끼친다는 의미이다.
  - **예상하지 못한 못한 버그가 발생할 가능성이 있다!!**
  - 하위 슬라이스에 append 혹은 수정하지 않도록 하자.
  - 완전한 슬라이스 연산을 사용할 수도 있다.

### 슬라이스에 사용할 수 있는 내장 함수
- **len()** -> slice 의 길이 확인, 문자열의 길이 확인 
  - len 함수를 통해 반환된 길이는 코드 단위의 길이가 아닌 byte 단위이다
  - 특수 문자등 여러 바이트를 차지하는 문자에 대한 길이를 확인할 떄 주의
- **append()** -> 슬라이스에 새로운 요소 추가
  - 반환된 슬라이스는 파라미터로 넘겨줬던 슬라이스에 다시 할당해야 한다.
  - 반환 값을 할당하지 않으면 컴파일 에러 발생
  - Go 는 call by value 방식을 사용하여 복사본의 슬라이스가 전달되기 때문이다.
```go
var x []int
x = append(x, 10)
x = append(x, 1, 2, 3, 5)

var y = []int{6, 7, 8}
x = append(x, y...)
x[0] = 99  // 0번 인덱스의 값 99로 변경
w := x[0]
fmt.Println(w)  // 99
```
- **cap()** -> 현재 슬라이스의 수용력 반환 (capacity)
- **make()** -> 타입, 길이, 선택적으로 수용력을 지정해 슬라이스 생성
  - make 함수 사용 시 길이를 N 으로 하는 경우 N 까지 인덱스가 타입의 제로값으로 초기화 된다.
```go
makeSlice := make([]int, 0)
```
- **copy()** -> 원본 슬라이스부터 메모리 독립적인 슬라이스를 생성한다.
```go
x := []int{1, 2, 3}
y := make([]int, 3)
_ = copy(y, x)
fmt.Println(y)  // [1, 2, 3]
```
### 슬라이스의 수용력
- 슬라이스는 일련의 값을 저장하는 자료 구조이고 각 요소는 연속되는 메모리 공간에 할당된다.
- 이런 특성이 값을 빠르게 읽고 쓰기가 가능하게 한다.
- 수용력이란 예약된 연속된 메모리 공간의 크기이다.
  - 수용력을 미리 정하는 경우 연속된 메모리 크기를 미리 할당하는 것이다.
- 실제 슬라이스의 길이와 수용력은 다를 수 있으며 슬라이스의 길이가 증가하면서 수용력만큼 차게 된다면 append 는 Go 런타임을 사용해 더 큰 수용력을 가지는 새로운 슬라이스로 할당한다.
  - 메모리를 새롭게 할당하는 것으로 새롭게 할당된 슬라이스로 기존의 값이 복사되고 새로운 슬라이스를 반환한다.
  - 이전 메모리는 가비지 컬렉션에서 정리가 필요하며 기존 데이터를 새로운 메모리로 복사하기 위한 시간이 필요하다.
- Go 런타임은 슬라이스 수용력이 다 차면 기존의 수용력의 2배만큼 증가시킨다.
  - 1.14 버전 규칙은 1024 이하의 경우 2배씩, 이상은 25% 씩 증가시킨다.
***
## 맵
```go
var nilMap map[string]int  // zero value : nil
literalMap := map[string]int{}  // nil 맵과 다른 비어있는 맵
nameMap := map[string]string{
	"dev-hippo-an" : "idiot",
	"ejejc" : "pretty"
}
makeMap := make(map[string]int, 0)  // 길이 지정한 맵 생성
```
- make 함수를 이용해서 기본 크기를 가지는 맵을 생성할 수 있다.
### 맵 읽기, 쓰기, 삭제하기
```go
score := map[string]int{}
score["dev-hippo-an"] = 10
score["ejejc"] = 100

fmt.Println(score["ejejc"])  // 100
fmt.Println(score["dev-hippo-an"])  // 10

delete(score, "dev-hippo-an")
fmt.Println(score["dev-hippo-an"])  // 존재하지 않는 키값이므로 밸류 타입의 제로값 출력 - 0
```
- 존재하지 않는 키 값에 대해서 밸류 타입의 제로값을 출력
  - 이 경우가 제로값으로 출력한 것인지 실제 값이 제로 값인지 확인하기 위해 콤마 OK 관용구 사용
```go
v, ok := score["dev-hippo-an"]
fmt.Println(v, ok)  // 0, false - 위에서 이미 삭제했기 때문에 존재하지 않는다.
v, ok = score["ejejc"]
fmt.Println(v, ok)  // 100, true
```

### 맵을 set 으로 사용하기
- Go 언어에서는 set 자료구조를 지원하지 않기 때문에 map 을 set 으로 사용하던 외부 라이브러리를 사용해야 한다.
```go
intSet := map[int]bool{}
vals := []int{5, 10, 2, 5, 8, 7, 3, 9, 1, 2, 10}
for _, v:= range vals {
	intSet[v] = true
}
fmt.Println(len(vals), len(intSet))
fmt.Println(intSet[5])
fmt.Println(intSet[500])
if intSet[100] {
	fmt.Println("100 is in the set")
}
```
### 맵과 슬라이스의 기능적 비슷한 부분
- 맵에 키-값이 추가되면 자동으로 커진다.
- 맵의 데이터 크기가 파악이 된다면 make 함수를 통해 특정 크기로 초기화 해 생성할 수 있다.
- len 함수에 map 을 넘겨 키-값 쌍의 수를 알 수 있다.
- 맵의 제로값은 nil 이다.
- 맵은 == 으로 비교가능하지 않다.
***
## 구조체 struct
- 여러 데이터 타입을 함께 구성할 때 사용할 수 있다.
```go
type person struct {
	name string
	age int
	pet string
}

var sh person  // 구조체가 가지는 모든 값을 제로값으로 가지는 구조체 생성
sehyeong := person{}  // 구조체 리터럴로 변수 할당 - 구조체가 가지는 모든 값을 제로값으로 가지는 구조체 생성
```
- 구조체의 타입 이름을 지정하지 않고 구조체 타입을 구현할 수 있으며 이를 익명 구조체라고 한다.
```go
pet := struct {
	name string
	kind string
} {
	name: "Merry",
	kind: "dog",
}

fmt.Println(pet)  // {Merry dog}
```
- 구조체의 항목이 비교 가능한 타입으로 구성되어 있는 경우 구조체는 == 을 통해 비교 가능
  - 그렇지 않은 경우 비교가 불가능하다.
  - Go 에서 구조체가 같은 여부를 확인하는 것은 생각보다 까다로워 보인다.
***
## Go 런타임
- 고급 언어는 해당 언어로 작성된 프로그램을 실행할 수 있는 라이브러리등의 지원을 한다.
- Go 런타임은 메모리 할당, 가비지 컬렉션, 동시성 지원, 네트워킹, 내장 타입과 같은 서비스 제공
- Go 런타임은 모든 Go 바이너리에 컴파일 되어 포함된다.
  - Go 바이너리에서 동일한 런타임 환경을 제공받을 수 있다.
