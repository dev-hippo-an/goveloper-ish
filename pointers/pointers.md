# 포인터

## 포인터 정의와 특징
- 포인터는 값이 저장된 메모리의 주소값
  - 모든 변수는 하나 혹은 그 이상의 연속적인 메모리 공간에 저장되며 이를 주소라 한다.
- 제로값은 nil
  - 슬라이스, 맵, 함수, 채널, 인터페이스 그리고 포인터
```go
var pointerX *string  // pointer 변수 생성
```
- & 주소 연산자 / * 역참조 연산자 
  - 주소 연산자는 변수의 주소값을 반환
  - 역참조 연산자는 포인터 타입의 변수에 가리키는 값을 반환
- 포인터 타입은 포인터가 어떤 타입을 가리키는지 나타낸다.
  - 타입의 이름 앞에 * 을 사용해 변수 지정
  - new 키워드를 사용해 포인터 타입의 변수 선언 가능 
    - new 키워드로 선언된 포인터 변수는 제공 타입의 제로 값을 가리키는 포인터 반환
```go
var x = new(int64)
fmt.Println(x == nil)  // false 
fmt.Println(*x)  // 0 
```
- 메모리 주소를 가지지 않는 기본 타입 리터럴(숫자, 불리언, 문자열) 과 상수는
  - & 를 사용해서 포인터 인스턴스를 만들 수 없다.
  - 구조체는 & 를 통해 선언과 동시에 포인터 인스턴스를 만들 수 있다.
    - 리터럴은 컴파일 과정에 존재, 메모리 주소 값이 없다
```go
compileError := &"Good Morning!"
compileError2 := &33

// 기본 타입 리터럴 혹은 상수 할당을 위해 변수 선언 후 해당 변수를 가리키는 포인터를 만든다.
x := &Foo{}
val := 12333
z := &val
```
- 포인터는 변경 가능한 파라미터
  - 값에 의한 호출을 사용하는 고언어는 함수로 전달된 값은 복사되어 전달
    - 비 포인터 타입(값 타입)을 파라미터로 가지는 함수 호출시
      - 함수 내부에서 원본 값을 수정할 수 없기 때문에 
      - 원본 값의 불변성을 보장
    - 포인터 타입이 함수 파라미터인 경우
      - 함수는 포인터(주소값)의 복사를 얻게 됨
      - 원본 데이터의 주소값을 가리기키며 이는 
      - 원본 데이터를 수정할 수 있다는 의미
  - 이미 값이 할당된 포인터 변수에 대해서만 값을 재 할당
    - 함수 파라미터로 nil 이 넘어갈 경우 새로운 값을 할당할 방법이 없다
  - 함수 종료 시 포인터 파라미터의 값을 유지하기 위해선 역 참조하여 값을 설정

- 맵, 슬라이스와 포인터
  - 맵과 슬라이스는 포인터로 구현되어 있다.
    - 함수 파라미터로 넘어가는 맵과 슬라이스는 모두 **복사본**
  - 맵은 구조체를 가리키는 포인터로 구현
  - 슬라이스는 3개의 항목을 가지는 구조체 포인터로 구현
    - 배열 주소, len, cap
    - 복사된 슬라이스의 길이와 수용력은 바꿀 수 없지만 이미 할당된 길이 내에서 배열의 내용을 바꿀 수 있다.

## gc 작업량 줄이기
- 가비지란 어떤 포인터로 가리키지 않은 데이터를 의미
- 함수가 실행될 때, 새로운 스택 프레임이 함수 데이터를 위해 생성
  - 지역 변수, 함수 파라미터가 스택에 저장
  - 메모리가 할당된 위치를 가르키는 스택 포인터를 이동시키며 변수 할당을 통한 추가 메모리 할당을 처리한다.
  - 함수 반환 시 함수의 반환값은 스택을 통해 호출된 함수로 복사된다.
    - 함수 반환 시 스택 포인터의 값을 함수 호출 초기 위치로 이동해 스택 메모리에 있는 데이터를 해제한다.
- go 컴파일러가 포인터 변수가 스택에 저장될 수 없다고 판단한 경우
  - 여러 복잡한 조건에의해 스택에 변수를 저장할지 여부를 고 런타임이 판단한다.
  - 포인터가 가리키는 데이터는 **힙 영역**에 저장된다.
  - 여기서 힙 영역은 gc 에 의해 관리되는 메모리다.
- 힙에 데이터를 저장하는게 나쁜 이유
  - 가비지 컬렉터의 작업 시간
    - 고 언어의 가비지 컬렉터는 낮은 지연 시간을 선호
    - 가비지가 많으면 소요 시간이 많이 걸려 가비지 컬렉터의 로드가 많이 걸린다.
  - 컴퓨터 하드웨어 특성 처리
    - 포인터 슬라이스는 램 전체에 데이터가 흩어져 있어 읽기 및 처리 속도가 훨씬 느리다.